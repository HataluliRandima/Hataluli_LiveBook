# Untitled notebook

## Project Stats

Building a statistics library for elixir. Having some idea on mean and median dealings with numbers in statistics.

## Central Tendency

Calculating the Mean(Average). Working with louis who stays at toronto . He want to calculae number of cars in toronto (Population). He wants to count number of cars in toronto out of all the cars in Canada(Sample).
Avg height of people in his house (Population Mean)
Avg height of people in toronto out of all the people in Canada (Sample Mean)

Avg candies sold in 3 hrs (This population Mean)bcs scope is limited to 3 hrs
example Candies sold = 10, 20,30

Mean = (10+20+30)/3=20 candles/hr

Avg candies sold in first 3hr out of full day (Sample Mean)
candies sold = 10,10,30,25,30,23,18,10

Mean = (10+20+30)/3=20 candles/hr

<!-- livebook:{"break_markdown":true} -->

Create error module to use on another modules it just return an atom for error .

```elixir
defmodule Errors do
  @spec invalid_data_type :: {:error, String.t()}
  def invalid_data_type, do: {:error, "Invalid Data Type"}
end
```

Create another file for validators

```elixir
defmodule Validators do
  alias Errors

  @spec validate_num_list([number()]) :: {boolean(), [number()]} | {atom(), String.t()}
  def validate_num_list(nums) when is_list(nums) do
    {Enum.all?(nums, fn el -> is_number(el) end), nums}
  end

  def validate_num_list(_), do: Errors.invalid_data_type()
end
```

Calculating of population and sample mean. See Examples below:

```elixir
defmodule Mean do
  alias Errors
  alias Validators

  # sum (sigma) / count

  # =============================x=======================================

  # function that will run incase our func has error or when we didnt give it a list
  @spec population_mean([number()]) :: number() | {:error, String.t()}
  def population_mean([]), do: Errors.invalid_data_type()

  # added some guard to our function
  # The function will only run if our guard is saisfied
  def population_mean(nums) when is_list(nums) do
    nums
    |> Validators.validate_num_list()
    |> calc_population_mean()
  end

  def population_mean(_), do: Errors.invalid_data_type()

  # ====================================================================

  @spec sample_mean([number()]) :: number() | {:error, String.t()}
  def sample_mean(nums), do: population_mean(nums)

  # ====================================================================

  # function to calculate our population mean
  defp calc_population_mean({false, _}), do: Errors.invalid_data_type()

  defp calc_population_mean({true, nums}) do
    nums
    |> Enum.sum()
    |> mean(Enum.count(nums))
  end

  # ====================================================================

  # sum (sigma) / count

  defp mean(sigma, count), do: sigma / count

  # ====================================================================
end
```

```elixir
Mean.population_mean([10, 20, 30])
```
